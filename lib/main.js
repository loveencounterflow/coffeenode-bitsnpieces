// Generated by CoffeeScript 1.7.1
(function() {
  var njs_path, validate_isa_number;

  njs_path = require('path');

  this.equals = function(a, b) {
    var assert, error;
    assert = require('assert');
    try {
      assert.deepEqual(a, b);
      return true;
    } catch (_error) {
      error = _error;
      return false;
    }
  };

  this.format_number = function(n) {
    var f, h;
    n = n.toString();
    f = function(n) {
      return h(n, /(\d+)(\d{3})/);
    };
    h = function(n, re) {
      while (re.test(n)) {
        n = n.replace(re, "$1" + "'" + "$2");
      }
      return n;
    };
    return f(n);
  };

  this.escape_regex = function(text) {

    /* Given a `text`, return the same with all regular expression metacharacters properly escaped. Escaped
    characters are `[]{}()*+?-.,\^$|#` plus whitespace.
     */
    return text.replace(/[-[\]{}()*+?.,\\\/^$|#\s]/g, "\\$&");
  };

  this.escape_html = function(text) {

    /* Given a `text`, return the same with all characters critical in HTML (`&`, `<`, `>`) properly
    escaped.
     */
    var R;
    R = text;
    R = R.replace(/&/g, '&amp;');
    R = R.replace(/</g, '&lt;');
    R = R.replace(/>/g, '&gt;');
    return R;
  };

  this.get_rnd = function(seed, delta) {
    var R;
    if (seed == null) {
      seed = 1;
    }
    if (delta == null) {
      delta = 1;
    }

    /* This method returns a simple deterministic pseudo-random number generator—basically like
    `Math.random`, but (1) very probably with a much worse distribution of results, and (2) with predictable
    series of numbers, which is good for some testing scenarios. You may seed this method by passing in a
    `seed` and a `delta`, both of which must be non-zero numbers; the ensuing series of calls to the returned
    method will then always result in the same series of numbers. Here is a usage example that also shows how
    to reset the generator:
    
        BAP = require 'coffeenode-bitsnpieces'
        rnd = BAP.get_rnd() # or, say, `rnd = BAP.get_rnd 123, 0.5`
        log BAP.rnd() for idx in [ 0 .. 5 ]
        log()
        rnd.reset()
        log BAP.rnd() for idx in [ 0 .. 5 ]
    
    Please note that there are no strong guarantees made about the quality of the generated values except the
    (1) deterministic repeatability, (2) boundedness, and (3) 'apparent randomness'. Do **not** use this for
    cryptographic purposes.
     */
    R = function() {
      var x;
      R._idx += 1;
      x = (Math.sin(R._s)) * 10000;
      R._s += R._delta;
      return x - Math.floor(x);
    };
    R.reset = function(seed, delta) {

      /* Reset the generator. After calling `rnd.reset` (or `rnd.seed` with the same arguments), ensuing calls
      to `rnd` will always result in the same sequence of pseudo-random numbers.
       */
      if (seed == null) {
        seed = this._seed;
      }
      if (delta == null) {
        delta = this._delta;
      }
      validate_isa_number(seed);
      validate_isa_number(delta);
      if (seed === 0) {
        throw new Error("seed should not be zero");
      }
      if (delta === 0) {
        throw new Error("delta should not be zero");
      }
      R._s = seed;
      R._seed = seed;
      R._delta = delta;
      R._idx = -1;
      return null;
    };
    R.reset(seed, delta);
    return R;
  };


  /* TAINT code duplication (to avoid dependency on CoffeeNode Types). */

  validate_isa_number = function(x) {
    if (!((Object.prototype.toString.call(x)) === '[object Number]' && isFinite(x))) {
      throw "expected a number, got " + ((require('util')).inspect(x));
    }
  };

  this.pluck = function(x, name, fallback) {

    /* Given some object `x`, a `name` and a `fallback`, return the value of `x[ name ]`, or, if it does not
    exist, `fallback`. When the method returns, `x[ name ]` has been deleted.
     */
    var R;
    if (x[name] != null) {
      R = x[name];
      delete x[name];
    } else {
      R = fallback;
    }
    return R;
  };

  this.get_parent_routes = function(route) {
    var R;
    R = [];
    while (true) {
      R.push(route);
      if (route.length === 0 || route === '/') {
        break;
      }
      route = njs_path.dirname(route);
    }
    return R;
  };

  this.get_V8_CallSite_objects = function(delta) {
    var R, error, prepareStackTrace_original;
    if (delta == null) {
      delta = 0;
    }

    /* Save original Error.prepareStackTrace */
    prepareStackTrace_original = Error.prepareStackTrace;
    Error.prepareStackTrace = function(ignored, stack) {
      return stack;
    };
    error = new Error();
    R = error.stack;

    /* Restore original Error.prepareStackTrace */
    Error.prepareStackTrace = prepareStackTrace_original;
    delta += 1;
    if (delta !== 0) {
      R.splice(0, delta);
    }
    return R;
  };

  this.get_caller_info_stack = function(delta) {
    var R, call_sites, cs, entry, _i, _len;
    if (delta == null) {
      delta = 0;
    }
    call_sites = this.get_V8_CallSite_objects(delta + 1);
    R = [];
    for (_i = 0, _len = call_sites.length; _i < _len; _i++) {
      cs = call_sites[_i];
      entry = {
        'function-name': cs.getFunctionName(),
        'method-name': cs.getMethodName(),
        'filename': cs.getFileName(),
        'line-nr': cs.getLineNumber(),
        'column-nr': cs.getColumnNumber()
      };
      R.push(entry);
    }
    return R;
  };

  this.get_caller_routes = function(delta) {
    var call_sites, cs;
    if (delta == null) {
      delta = 0;
    }
    call_sites = this.get_V8_CallSite_objects(delta + 1);
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = call_sites.length; _i < _len; _i++) {
        cs = call_sites[_i];
        _results.push(cs.getFileName());
      }
      return _results;
    })();
  };

  this.get_filtered_caller_routes = function(delta) {
    var R, call_sites, cs, route, seen_routes, _i, _len;
    if (delta == null) {
      delta = 0;
    }
    call_sites = this.get_V8_CallSite_objects(delta + 1);
    seen_routes = {};
    R = [];
    for (_i = 0, _len = call_sites.length; _i < _len; _i++) {
      cs = call_sites[_i];
      route = cs.getFileName();

      /* ignore all duplicate routes: */
      if (seen_routes[route] != null) {
        continue;
      }
      seen_routes[route] = 1;

      /* ignore all 'internal' routes (these typically have no slash, other routes being absolute): */
      if ((route.indexOf('/')) === -1) {
        continue;
      }
      R.push(route);
    }
    return R;
  };

  this.create_id = function(values, length) {

    /* Given a number of `values` and a `length`, return an ID with `length` hexadecimal digits (`[0-9a-f]`)
    that deterministically depends on the input but can probably not reverse-engeneered to yield the input
    values. This is in no way meant to be cryptographically strong, just arbitrary enough so that we have a
    convenient method to derive an ID with little chance of overlap given different inputs. **Note** It is
    certainly possible to use this method (or `id_from_text`) to create a hash from a password to be stored in
    a DB. Don't do this. Use `bcrypt` or similar best-practices for password storage. Again, the intent of
    the BITSNPIECES ID utilities is *not* to be 'crypto-safe'; its intent is to give you a tool for generating
    repetition-free IDs.
     */
    var rpr, value;
    rpr = (require('util')).inspect;
    return this.id_from_text(((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push(rpr(value));
      }
      return _results;
    })()).join('-'), length);
  };

  this.create_random_id = function(values, length) {

    /* Like `create_id`, but with an extra random factor built in that should exclude that two identical
    outputs are ever returned for any two identical inputs. Under the assumption that two calls to this
    method are highly unlikely two produce an identical pair `( 1 * new Date(), Math.random() )` (which could
    only happen if `Math.random()` returned the same number again *within the same clock millisecond*), and
    assuming you are using a reasonable value for `length` (i.e., say, `7 < length < 20`), you should never
    see the same ID twice.
     */
    values.push(1 * new Date() * Math.random());
    return this.create_id(values, length);
  };

  this.get_create_rnd_id = function(seed, delta) {

    /* Given an optional `seed` and `delta`, returns a function that will create pseudo-random IDs similar to
    the ones `create_random_id` returns; however, the Bits'n'Pieces `get_rnd` method is used to obtain a
    repeatable random number generator so that ID sequences are repeatable. The underlying PRNG is exposed as
    `fn.rnd`, so `fn.rnd.reset` may be used to start over.
    
    **Use Case Example**: The below code demonstrates the interesting properties of the method returned by
    `get_create_rnd_id`: **(1)** we can seed the PRNG with numbers of our choice, so we get a chance to create
    IDs that are unlikely to be repeated by other people using the same software, even when later inputs (such
    as the email adresses shown here) happen to be the same. **(2)** Calling the ID generator with three
    diffferent user-specific inputs, we get three different IDs, as expected. **(3)** Repeating the ID
    generation calls with the *same* arguments will yield *different* IDs. **(4)** After calling
    `create_rnd_id.rnd.reset()` and feeding `create_rnd_id` with the *same* user-specific inputs, we can still
    see the identical *same* IDs generated—which is great for testing.
    
        create_rnd_id = BAP.get_create_rnd_id 1234, 87.23
    
         * three different user IDs:
        log create_rnd_id [ 'foo@example.com' ], 12
        log create_rnd_id [ 'alice@nosuchname.com' ], 12
        log create_rnd_id [ 'tim@cern.ch' ], 12
    
         * the same repeated, but yielding random other IDs:
        log()
        log create_rnd_id [ 'foo@example.com' ], 12
        log create_rnd_id [ 'alice@nosuchname.com' ], 12
        log create_rnd_id [ 'tim@cern.ch' ], 12
    
         * the same repeated, but yielding random other IDs:
        log()
        create_rnd_id.rnd.reset()
        log create_rnd_id [ 'foo@example.com' ], 12
        log create_rnd_id [ 'alice@nosuchname.com' ], 12
        log create_rnd_id [ 'tim@cern.ch' ], 12
    
    The output you should see is
    
        c40f774fce65
        9d44f31f9a55
        1b26e6e3e736
    
        a0e11f616685
        d7242f6935c7
        976f26d1b25b
    
        c40f774fce65
        9d44f31f9a55
        1b26e6e3e736
    
    Note the last three IDs exactly match the first three IDs. The upshot of this is that we get reasonably
    hard-to-guess, yet on-demand replayable IDs. Apart from weaknesses in the PRNG itself (for which see the
    caveats in the description to `get_rnd`), the obvious way to cheat the system is by making it so that
    a given piece of case-specific data is fed into the ID generator as the n-th call a second time. In
    theory, we could make it so that each call constributes to the state change inside of `create_rnd_id`;
    a replay would then need to provide all of the case-specific pieces of data a second time, in the right
    order.
     */
    var R;
    R = (function(_this) {
      return function(values, length) {
        values.push(R.rnd());
        return _this.create_id(values, length);
      };
    })(this);
    R.rnd = this.get_rnd(seed, delta);
    return R;
  };

  this.id_from_text = function(text, length) {

    /* Given a `text` and a `length`, return an ID with `length` hexadecimal digits (`[0-9a-f]`)—this is like
    `create_id`, but working on a text rather than a number of arbitrary values. The hash algorithm currently
    used is SHA-1, which returns 40 hex digits; it should be good enough for the task at hand and has the
    advantage of being widely implemented.
     */

    /* TAINT should be a user option, or take 'good' algorithm universally available */
    var R;
    R = (((require('crypto')).createHash('sha1')).update(text, 'utf-8')).digest('hex');
    if (length != null) {
      return R.slice(0, length);
    } else {
      return R;
    }
  };

  this.get_app_home = function(routes) {
    var error, njs_fs, route, _i, _len;
    if (routes == null) {
      routes = null;
    }

    /* Return the file system route to the current (likely) application folder. This works by traversing all
    the routes in `require[ 'main' ][ 'paths' ]` and checking whether one of the `node_modules` folders
    listed there exists and is a folder; the first match is accepted and returned. If no matching existing
    route is found, an error is thrown.
    
    NB that the algorithm works even if the CoffeeNode Options module has been symlinked from another location
    (rather than 'physically' installed) and even if the application main file has been executed from outside
    the application folder (i.e. this obviates the need to `cd ~/route/to/my/app` before doing `node ./start`
    or whatever—you can simply do `node ~/route/to/my/app/start`), but it does presuppose that (1) there *is*
    a `node_modules` folder in your app folder; (2) there is *no* `node_modules` folder in the subfolder or
    any of the intervening levels (if any) that contains your startup file. Most modules that follow the
    established NodeJS / npm way of structuring modules should naturally comply with these assumptions.
     */
    njs_fs = require('fs');
    if (routes == null) {
      routes = require['main']['paths'];
    }
    for (_i = 0, _len = routes.length; _i < _len; _i++) {
      route = routes[_i];
      try {
        if ((njs_fs.statSync(route)).isDirectory()) {
          return njs_path.dirname(route);
        }
      } catch (_error) {
        error = _error;

        /* silently ignore missing routes: */
        if (error['code'] === 'ENOENT') {
          continue;
        }
        throw error;
      }
    }
    throw new Error("unable to determine application home; tested routes: \n\n " + (routes.join('\n ')) + "\n");
  };

  this.compile_options = function(options) {
    var TYPES, count_key, name, type, value;
    TYPES = require('coffeenode-types');
    count_key = this.compile_options.count_key;
    if (options[count_key] == null) {
      options[count_key] = 0;
    }
    for (name in options) {
      value = options[name];
      switch (type = TYPES.type_of(value)) {
        case 'text':
          this.compile_options.resolve_name.call(this, options, null, name, value);
          break;
        case 'pod':
          null;
          break;
        case 'list':
          null;
      }
    }
    return options;
  };

  this._walk_facets = function(value, handler, crumbs) {
    var TYPES;
    TYPES = require('coffeenode-types');
    if (crumbs == null) {
      crumbs = [];
    }
    if (TYPES.isa_pod(value)) {
      return this._walk_pod_facets(value, handler, crumbs);
    } else if (TYPES.isa_list(value)) {
      return this._walk_list_facets(value, handler, crumbs);
    }
    return handler(null, crumbs, value);
  };

  this._walk_list_facets = function(list, handler, crumbs) {
    var idx, value, _i, _len, _results;
    _results = [];
    for (idx = _i = 0, _len = list.length; _i < _len; idx = ++_i) {
      value = list[idx];
      crumbs.push(idx);
      this._walk_facets(value, handler, crumbs);
      _results.push(crumbs.pop());
    }
    return _results;
  };

  this._walk_pod_facets = function(pod, handler, crumbs) {
    var name, value, _results;
    _results = [];
    for (name in pod) {
      value = pod[name];
      crumbs.push(name);
      this._walk_facets(value, handler, crumbs);
      _results.push(crumbs.pop());
    }
    return _results;
  };

  this.compile_options.count_key = '%BITSNPIECES/compile-options/change-count';

  this.compile_options.no_name_re = /^\\\$/;

  this.compile_options.name_re = /^\$([-_a-zA-Z0-9]+)$/;

  this.compile_options.resolve_name = function(options, container, key, value) {
    var count_key, match, new_name, new_value, rpr;
    rpr = (require('util')).inspect;
    count_key = this.compile_options.count_key;
    if (container == null) {
      container = options;
    }
    if ((match = value.match(this.compile_options.name_re)) != null) {
      new_name = match[1];
      new_value = options[new_name];
      if (new_value === void 0) {
        throw new Error("member " + (rpr(key)) + " references undefined key as " + (rpr(value)));
      }
      container[key] = new_value;
      options[count_key] += 1;
      debug("replaced " + (rpr(key)) + ": " + (rpr(value)) + " with " + (rpr(new_name)) + ": " + (rpr(new_value)));
    } else {
      new_value = value.replace(this.compile_options.no_name_re, '$');
      container[key] = new_value;
      if (value !== new_value) {
        options[count_key] += 1;
        debug("replaced " + (rpr(value)) + " with " + (rpr(new_value)));
      }
    }
    return options;
  };

  this._value_from_locator = function(container, locator, fallback) {
    var crumbs, rpr;
    if (fallback == null) {
      fallback = void 0;
    }
    rpr = (require('util')).inspect;
    crumbs = locator.split('/');
    if (crumbs[0] !== '') {
      throw new Error("expected a locator starting with a slash, got " + (rpr(locator)));
    }
    crumbs.shift();
    return this._value_from_crumbs(container, locator, crumbs, fallback);
  };

  this._value_from_crumbs = function(container, locator, crumbs, fallback) {
    var error;
    if (fallback == null) {
      fallback = void 0;
    }
    try {
      return this._value_from_crumbs_inner(container, locator, crumbs);
    } catch (_error) {
      error = _error;
      if (/^unable to resolve name/.test(error['message'])) {
        if (fallback !== void 0) {
          return fallback;
        }
      }
      throw error;
    }
  };

  this._value_from_crumbs_inner = function(container, locator, crumbs) {
    var error, first_crumb, rpr, sub_container;
    rpr = (require('util')).inspect;
    first_crumb = crumbs.shift();
    try {
      sub_container = container[first_crumb];
    } catch (_error) {
      error = _error;
      sub_container = void 0;
    }
    if (sub_container === void 0) {
      throw new Error("unable to resolve name " + (rpr(first_crumb)) + " in locator " + (rpr(locator)));
    }
    if (crumbs.length === 0) {
      return sub_container;
    }
    return this._value_from_crumbs_inner(sub_container, locator, crumbs);
  };

}).call(this);
